import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const LINE_TOKEN_URL = "https://api.line.me/oauth2/v2.1/token";
const LINE_PROFILE_URL = "https://api.line.me/v2/profile";

interface LineTokenResponse {
    access_token: string;
    token_type: string;
    refresh_token: string;
    expires_in: number;
    scope: string;
    id_token: string;
}

interface LineProfile {
    userId: string;
    displayName: string;
    pictureUrl?: string;
    statusMessage?: string;
}

serve(async (req) => {
    try {
        const url = new URL(req.url);
        const code = url.searchParams.get("code");
        const state = url.searchParams.get("state");

        if (!code || !state) {
            return new Response("Missing code or state", { status: 400 });
        }

        // Parse state to get mode and optional invite token
        // Parse state to get mode and optional invite token
        const stateParts = state.split(":");
        const mode = stateParts[1];
        let extraParam = stateParts[2] || null;

        // Sanitize extraParam
        if (extraParam === "null" || extraParam === "undefined") {
            extraParam = null;
        }

        const inviteToken = mode !== 'link' ? extraParam : null;
        const linkUserId = mode === 'link' ? extraParam : null;

        console.log("=== DEBUG LOGS ===");
        console.log("Raw State:", state);
        console.log("State Parts:", JSON.stringify(stateParts));
        console.log("Mode:", mode);
        console.log("Extra Param:", extraParam);
        console.log("Invite Token:", inviteToken);
        console.log("Link User ID:", linkUserId);
        console.log("==================");

        // Get environment variables
        const channelId = Deno.env.get("LINE_CHANNEL_ID");
        const channelSecret = Deno.env.get("LINE_CHANNEL_SECRET");
        const callbackUrl = Deno.env.get("LINE_CALLBACK_URL");
        // Supabase automatically provides these
        const supabaseUrl = Deno.env.get("SUPABASE_URL");
        const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
        const frontendUrl = Deno.env.get("FRONTEND_URL") || "http://localhost:3000";

        if (!channelId || !channelSecret || !callbackUrl || !supabaseUrl || !supabaseServiceKey) {
            return new Response("Missing configuration", { status: 500 });
        }

        // Exchange code for access token
        const tokenParams = new URLSearchParams({
            grant_type: "authorization_code",
            code,
            redirect_uri: callbackUrl,
            client_id: channelId,
            client_secret: channelSecret,
        });

        const tokenResponse = await fetch(LINE_TOKEN_URL, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            },
            body: tokenParams.toString(),
        });

        if (!tokenResponse.ok) {
            const error = await tokenResponse.text();
            console.error("Token exchange failed:", error);
            return new Response(`Token exchange failed: ${error}`, { status: 500 });
        }

        const tokenData: LineTokenResponse = await tokenResponse.json();

        // Get LINE user profile
        const profileResponse = await fetch(LINE_PROFILE_URL, {
            headers: {
                Authorization: `Bearer ${tokenData.access_token}`,
            },
        });

        if (!profileResponse.ok) {
            const error = await profileResponse.text();
            console.error("Profile fetch failed:", error);
            return new Response(`Profile fetch failed: ${error}`, { status: 500 });
        }

        const profile: LineProfile = await profileResponse.json();

        // Create Supabase admin client
        const supabase = createClient(supabaseUrl, supabaseServiceKey, {
            auth: {
                autoRefreshToken: false,
                persistSession: false,
            },
        });

        // Email for this LINE user
        const email = `${profile.userId}@line.nightbase.app`;

        let userId: string | null = null;
        let invitedProfileId: string | null = null;

        // PRIORITY 0: Handle account linking
        if (linkUserId) {
            console.log("Processing account linking for user:", linkUserId);
            userId = linkUserId;

            // Check if this LINE ID is already linked to another user
            const { data: existingLinkedProfiles } = await supabase
                .from("profiles")
                .select("user_id")
                .eq("line_user_id", profile.userId);

            const isLinkedToOther = existingLinkedProfiles?.some((p: any) => p.user_id !== userId);

            if (isLinkedToOther) {
                return new Response("このLINEアカウントは既に他のユーザーと連携されています", { status: 400 });
            }

            // Protect existing email users' authentication credentials
            // Get existing user info from Auth and public.users
            const { data: existingAuthUser } = await supabase.auth.admin.getUserById(linkUserId);
            const { data: existingUserData } = await supabase
                .from("users")
                .select("email, primary_email")
                .eq("id", linkUserId)
                .maybeSingle();

            // Check if this is an email user (not a LINE placeholder email)
            const isEmailUser = existingAuthUser?.user?.email &&
                !existingAuthUser.user.email.endsWith("@line.nightbase.app");

            console.log("Link - isEmailUser:", isEmailUser);
            console.log("Link - auth email:", existingAuthUser?.user?.email);
            console.log("Link - users data:", existingUserData);

            if (isEmailUser) {
                // This is a mail-registered user linking their LINE account
                // We need to preserve their email login credentials

                // Set primary_email if not already set
                if (!existingUserData?.primary_email) {
                    console.log("Setting primary_email for email user:", existingAuthUser.user.email);
                    await supabase
                        .from("users")
                        .update({ primary_email: existingAuthUser.user.email })
                        .eq("id", linkUserId);
                }

                // DO NOT change auth.users.email or password
                // DO NOT change public.users.email
                // This allows the user to continue logging in with their email and password
            }

            // Update all profiles for this user with LINE info
            // Or should we only update the current profile? 
            // Usually linking is per-user, so updating all profiles for this user seems correct
            // as they represent the same person in different stores.
            const { error: updateError } = await supabase
                .from("profiles")
                .update({
                    line_user_id: profile.userId,
                    avatar_url: profile.pictureUrl,
                })
                .eq("user_id", userId);

            if (updateError) {
                console.error("Failed to link account:", updateError);
                return new Response(`連携に失敗しました: ${updateError.message}`, { status: 500 });
            }

            // Redirect back to me page with timestamp to bust cache
            const finalUrl = new URL(`${frontendUrl}/app/me`);
            finalUrl.searchParams.set('_t', Date.now().toString());
            return new Response(null, {
                status: 302,
                headers: {
                    "Location": finalUrl.toString(),
                    "Cache-Control": "no-cache, no-store, must-revalidate",
                },
            });
        }

        // PRIORITY 1: Handle invitation if token exists
        if (inviteToken) {
            // Validate UUID format
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (!uuidRegex.test(inviteToken)) {
                console.error("Invalid invite token format:", inviteToken);
                // Treat as invalid token, but don't crash - just proceed as normal login
            } else {
                console.log("Processing invitation with token:", inviteToken);

                // Verify invite token
                const { data: invitedProfile, error: inviteError } = await supabase
                    .from("profiles")
                    .select("id, user_id, invite_status, invite_expires_at")
                    .eq("invite_token", inviteToken)
                    .maybeSingle();

                if (inviteError) {
                    console.error("Invitation fetch error details:", JSON.stringify(inviteError));
                } else if (!invitedProfile) {
                    console.error("Invitation not found for token:", inviteToken);
                    return new Response("招待が見つかりません", { status: 404 });
                } else if (invitedProfile.invite_status !== "pending") {
                    console.error("Invitation is not pending:", invitedProfile.invite_status);
                    return new Response("この招待は既に使用されているか、無効です", { status: 400 });
                } else {
                    // Valid invitation found
                    invitedProfileId = invitedProfile.id;
                    console.log("Invited profile ID:", invitedProfileId);

                    // Check if invited profile already has a user_id
                    if (invitedProfile.user_id) {
                        // Profile already linked to a user - use that user
                        userId = invitedProfile.user_id;

                        // Update user password using admin API
                        const password = profile.userId;
                        const { error: updateError } = await supabase.auth.admin.updateUserById(userId, {
                            password: password,
                        });

                        if (updateError) {
                            console.error("Password update failed:", updateError);
                        }
                    }
                }
            }
        }

        // If we have an invited profile but no user yet, create one and link it
        if (invitedProfileId && !userId) {
            // Profile not yet linked - create new user and link to invited profile
            const password = profile.userId;
            let { data: newAuthUser, error: authError } = await supabase.auth.admin.createUser({
                email,
                password: password,
                email_confirm: true,
                user_metadata: {
                    line_user_id: profile.userId,
                    name: profile.displayName,
                    avatar_url: profile.pictureUrl,
                },
            });

            if (authError) {
                // Check if error is because user already exists
                if (authError.message?.includes("already been registered")) {
                    console.log("User already exists, attempting to recover userId...");

                    // Strategy 1: Try to sign in with the expected password (LINE user ID)
                    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                        email,
                        password: password,
                    });

                    if (signInData.user) {
                        console.log("Recovered userId via sign-in");
                        newAuthUser = { user: signInData.user };
                    } else {
                        console.log("Sign-in recovery failed, trying listUsers...", signInError);

                        // Strategy 2: Use listUsers to find by email (with higher limit)
                        const { data: users, error: listError } = await supabase.auth.admin.listUsers({
                            page: 1,
                            perPage: 1000
                        });

                        if (listError) {
                            console.error("listUsers failed:", listError);
                        }

                        const foundUser = users?.users.find((u: any) => u.email === email);

                        if (foundUser) {
                            console.log("Recovered userId via listUsers");
                            newAuthUser = { user: foundUser };
                        } else {
                            console.error("User exists but could not be found via sign-in or listUsers");
                            return new Response(`ユーザーの作成に失敗しました: ${authError.message}`, { status: 500 });
                        }
                    }
                } else {
                    console.error("User creation failed:", authError);
                    return new Response(`ユーザーの作成に失敗しました: ${authError.message}`, { status: 500 });
                }
            }

            if (!newAuthUser?.user) {
                return new Response("ユーザーの作成に失敗しました", { status: 500 });
            }

            userId = newAuthUser.user.id;

            // Link the LINE user to the invited profile and update invite status
            const { error: updateProfileError } = await supabase
                .from("profiles")
                .update({
                    user_id: userId,
                    line_user_id: profile.userId,
                    avatar_url: profile.pictureUrl,
                    invite_status: "accepted",
                    invite_token: null, // Clear token
                    invite_expires_at: null
                })
                .eq("id", invitedProfileId);

            if (updateProfileError) {
                console.error("Failed to link profile to user:", updateProfileError);
                return new Response("プロフィールのリンクに失敗しました", { status: 500 });
            }

            // Create or update users table record with current_profile_id
            const { error: upsertUserError } = await supabase
                .from("users")
                .upsert({
                    id: userId,
                    current_profile_id: invitedProfileId
                }, {
                    onConflict: "id"
                });

            if (upsertUserError) {
                console.error("Failed to create/update users record:", upsertUserError);
                return new Response("ユーザーレコードの作成に失敗しました", { status: 500 });
            }
        }

        // If userId is still not set (no invitation or invalid), try normal login/registration
        let loginEmail = email;
        let isEmailUser = false; // Track if this is an email user (not LINE-only)

        // If userId is still not set (no invitation or invalid), try normal login/registration
        if (!userId) {
            // Check if this LINE user is already linked to an existing account
            const { data: linkedProfile } = await supabase
                .from("profiles")
                .select("user_id")
                .eq("line_user_id", profile.userId)
                .limit(1)
                .maybeSingle();

            if (linkedProfile) {
                // User already exists with this LINE ID
                userId = linkedProfile.user_id;

                // Get current auth user email
                const { data: authUser } = await supabase.auth.admin.getUserById(userId);

                // Check if this is an email user (not a LINE placeholder email)
                // Email users should keep their original password
                isEmailUser = authUser?.user?.email &&
                    !authUser.user.email.endsWith("@line.nightbase.app");

                console.log("Re-login - isEmailUser:", isEmailUser);
                console.log("Re-login - auth email:", authUser?.user?.email);

                if (isEmailUser) {
                    // This is an email user who has linked their LINE account
                    // Use their auth email for login and DO NOT change password
                    loginEmail = authUser.user.email;

                    // Set primary_email if not already set (for email users who linked before the fix)
                    const { data: userData } = await supabase
                        .from("users")
                        .select("primary_email")
                        .eq("id", userId)
                        .maybeSingle();

                    if (!userData?.primary_email) {
                        console.log("Setting primary_email during re-login for email user:", authUser.user.email);
                        await supabase
                            .from("users")
                            .update({ primary_email: authUser.user.email })
                            .eq("id", userId);
                    }

                    // DO NOT update password - preserve user's email login password
                } else if (authUser?.user?.email) {
                    // This is a LINE-only user (email ends with @line.nightbase.app)
                    loginEmail = authUser.user.email;
                    // Update password to LINE user ID for consistent LINE login
                    await supabase.auth.admin.updateUserById(userId, {
                        password: profile.userId,
                    });
                } else {
                    // Fallback to LINE email format
                    loginEmail = `${profile.userId}@line.nightbase.app`;
                }
            } else {
                // New LINE user

                // If mode is 'login', do not create a new user automatically.
                // Redirect to unregistered page instead.
                if (mode === "login") {
                    console.log("User not found in login flow, redirecting to unregistered page...");
                    const redirectUrl = `${frontendUrl}/login/unregistered`;

                    return new Response(null, {
                        status: 302,
                        headers: {
                            "Location": redirectUrl,
                            "Cache-Control": "no-cache, no-store, must-revalidate",
                        },
                    });
                }

                // Create new user with password (LINE user ID as password)
                // loginEmail is already set to default

                let { data: newAuthUser, error: authError } = await supabase.auth.admin.createUser({
                    email: loginEmail,
                    password: profile.userId,
                    email_confirm: true,
                    user_metadata: {
                        line_user_id: profile.userId,
                        name: profile.displayName,
                        avatar_url: profile.pictureUrl,
                    },
                });

                if (authError) {
                    // Check if error is because user already exists
                    if (authError.message?.includes("already been registered")) {
                        console.log("User already exists, attempting to recover userId...");

                        // Strategy 1: Try to sign in with the expected password (LINE user ID)
                        const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                            email: loginEmail,
                            password: profile.userId,
                        });

                        if (signInData.user) {
                            console.log("Recovered userId via sign-in");
                            newAuthUser = { user: signInData.user };
                        } else {
                            console.log("Sign-in recovery failed, trying listUsers...", signInError);

                            // Strategy 2: Use listUsers to find by email (with higher limit)
                            const { data: users, error: listError } = await supabase.auth.admin.listUsers({
                                page: 1,
                                perPage: 1000
                            });

                            if (listError) {
                                console.error("listUsers failed:", listError);
                            }

                            const foundUser = users?.users.find((u: any) => u.email === loginEmail);

                            if (foundUser) {
                                console.log("Recovered userId via listUsers");
                                newAuthUser = { user: foundUser };
                            } else {
                                console.error("User exists but could not be found via sign-in or listUsers");
                                return new Response(`ユーザーの作成に失敗しました: ${authError.message}`, { status: 500 });
                            }
                        }
                    } else {
                        console.error("User creation failed:", authError);
                        return new Response(`ユーザーの作成に失敗しました: ${authError.message}`, { status: 500 });
                    }
                }

                if (!newAuthUser?.user) {
                    return new Response("ユーザーの作成に失敗しました", { status: 500 });
                }

                userId = newAuthUser.user.id;

                // Create profile for new user
                const { error: profileError } = await supabase
                    .from("profiles")
                    .insert({
                        user_id: userId,
                        line_user_id: profile.userId,
                        real_name: profile.displayName,
                        avatar_url: profile.pictureUrl,
                    });

                if (profileError) {
                    console.error("Profile creation failed:", profileError);
                    return new Response(`プロフィールの作成に失敗しました: ${profileError.message}`, { status: 500 });
                }

                // Create users table record
                const { error: upsertUserError } = await supabase
                    .from("users")
                    .upsert({
                        id: userId,
                        // current_profile_id will be set when they create a store or join one
                    }, {
                        onConflict: "id"
                    });

                if (upsertUserError) {
                    console.error("Failed to create users record:", upsertUserError);
                }
            }

            // Sign in and get session tokens
            let sessionTokens: { access_token: string; refresh_token: string };

            if (isEmailUser) {
                // For email users who have linked their LINE account,
                // we cannot use password authentication because we don't know their password.
                // Instead, use Admin API to create a session directly.
                console.log("Email user LINE login - creating session via Admin API");

                // Use Admin API to create a session token for the user
                const { data: adminSession, error: adminError } = await supabase.auth.admin.createUser({
                    email: loginEmail,
                    email_confirm: true,
                });

                if (adminError) {
                    // User might already exist, try to get existing user
                    const { data: existingUser } = await supabase.auth.admin.getUserById(userId);
                    if (!existingUser?.user) {
                        console.error("Failed to get user:", adminError);
                        return new Response(`ユーザーの取得に失敗しました`, { status: 500 });
                    }
                }

                // Generate a password reset token and use it to create a session
                const { data: resetData, error: resetError } = await supabase.auth.admin.generateLink({
                    type: 'recovery',
                    email: loginEmail,
                });

                if (resetError || !resetData) {
                    console.error("Failed to generate recovery link:", resetError);
                    return new Response(`セッションの作成に失敗しました`, { status: 500 });
                }

                // Extract the token from the recovery link
                const url = new URL(resetData.properties.action_link);
                const token = url.searchParams.get("token");
                const type = url.searchParams.get("type");

                if (!token) {
                    console.error("No token in recovery link");
                    return new Response(`トークンの取得に失敗しました`, { status: 500 });
                }

                // Use the reset token to create a session
                const { data: verifyData, error: verifyError } = await supabase.auth.verifyOtp({
                    token_hash: token,
                    type: 'recovery',
                });

                if (verifyError || !verifyData.session) {
                    console.error("Failed to verify OTP:", verifyError);
                    return new Response(`セッションの作成に失敗しました`, { status: 500 });
                }

                sessionTokens = {
                    access_token: verifyData.session.access_token,
                    refresh_token: verifyData.session.refresh_token,
                };
            } else {
                // For LINE-only users, sign in with LINE user ID as password
                const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                    email: loginEmail,
                    password: profile.userId,
                });

                if (signInError || !signInData.session) {
                    console.error("Sign in failed:", signInError);
                    console.error("Attempted email:", loginEmail);
                    return new Response(`ログインに失敗しました: ${signInError?.message}`, { status: 500 });
                }

                sessionTokens = {
                    access_token: signInData.session.access_token,
                    refresh_token: signInData.session.refresh_token,
                };
            }

            // Check if user has a profile and store
            const { data: userProfile } = await supabase
                .from("profiles")
                .select("id, real_name, store_id")
                .eq("user_id", userId)
                .limit(1)
                .maybeSingle();

            // Determine redirect URL based on existing data
            let redirectUrl: string;

            if (inviteToken) {
                // Invitation flow: always go to dashboard after processing
                redirectUrl = `${frontendUrl}/app/dashboard`;
            } else if (userProfile && userProfile.real_name && userProfile.store_id) {
                // User has profile and store, go to dashboard
                redirectUrl = `${frontendUrl}/app/dashboard`;
            } else if (mode === "create-store") {
                // Creating new store, go to profile/store setup
                redirectUrl = `${frontendUrl}/onboarding/profile?mode=create`;
            } else if (mode === "join-store") {
                // Joining existing store
                redirectUrl = `${frontendUrl}/onboarding/select-store`;
            } else if (mode === "onboarding") {
                // Onboarding flow: go to choice page
                redirectUrl = `${frontendUrl}/onboarding/choice`;
            } else {
                // Default: go to dashboard
                redirectUrl = `${frontendUrl}/app/dashboard`;
            }

            // Check friendship status
            let isFriend = false;
            try {
                const friendshipResponse = await fetch("https://api.line.me/friendship/v1/status", {
                    headers: {
                        Authorization: `Bearer ${tokenData.access_token}`,
                    },
                });

                if (friendshipResponse.ok) {
                    const friendshipData = await friendshipResponse.json();
                    isFriend = friendshipData.friendFlag;
                } else {
                    console.error("Friendship check failed:", await friendshipResponse.text());
                }
            } catch (error) {
                console.error("Friendship check error:", error);
            }

            // Redirect to frontend callback page to handle session setting
            const finalUrl = new URL(`${frontendUrl}/auth/line-callback`);
            finalUrl.searchParams.set("access_token", sessionTokens.access_token);
            finalUrl.searchParams.set("refresh_token", sessionTokens.refresh_token);
            finalUrl.searchParams.set("is_friend", String(isFriend));
            finalUrl.searchParams.set("next", redirectUrl.replace(frontendUrl || "", "")); // Relative path for next

            return new Response(null, {
                status: 302,
                headers: {
                    "Location": finalUrl.toString(),
                },
            });

        } catch (error) {
            console.error("Callback error:", error);
            return new Response(`Internal error: ${(error as Error).message}`, { status: 500 });
        }
    });
